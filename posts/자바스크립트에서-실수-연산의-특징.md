# 자바스크립트에서 실수 연산의 특징

📅 2025-04-10T14:18:53.692Z

🔗 [원문 링크](https://velog.io/@son-dan-ha/자바스크립트에서-실수-연산의-특징)

---



# 출력 결과는?

`console.log(1.3 + 0.1 == 1.4)`

다음 코드는 1.3 과 0.1 의 합이 1.4 와 같은지를 묻는다. 단순한 계산이므로 충분히 그 결과를 유추할 수 있다. 두 값의 합은 1.4이므로 위 코드를 실행했을 때 `True`가 출력될 것이다. 

그러나 출력 결과는 `False` 이다. 그 이유에 대해 알아보자.
<br><br><br>
<hr>

# 컴퓨터

컴퓨터는 0과 1로 이루어져 있다. 따라서 우리가 **10진수의 값**을 컴퓨터에게 주면 컴퓨터는 **2진수로 변환한 값**을 저장한다. 

문자 또한 마찬가지다. 특정 문자마다 지정된 **숫자 코드**가 있어서 그 기준에 맞게 문자를 **숫자로 변환**한다. 이를 문자 인코딩이라고 하며, 표준으로 *ASCII*와 *Unicode*가 사용된다. 이때 변환되는 숫자는 10진수이다. 컴퓨터는 이를 다시 **2진수**로 변환하여 저장한다. 

위 코드의 출력 결과가 `False`인 **이유**는 바로 이 **변환 과정**에서 나온다.
<br><br>
<hr>

# 2진수로 변환하기

직접 10진수를 2진수로 바꿔보자. 

변환 계산은 실수의 경우 정부 부분과 소수 부분을 나눠 계산한다. 
계산에는 여러 방법이 존재하며, 여기에서는 다음과 같은 방법을 적용하여 계산했다. 
<br><br>

## 정수 계산

2의 거듭제곱을 이용하는 방법이다. 

왼쪽부터 $2^0, 2^1, 2^2, 2^3 ···· ,2^n$ 을 나열하여, 합산 했을 때 10진수의 값이 나오는 자리에 1을 아닌것에 0을 부여하여 2진수를 구한다. 

13을 2진수로 변환하는 계산 과정이다. 
>
| $2^3$ | $2^2$ | $2^1$ | $2^0$ |
|:----:|:----:|:----:|:----:|
|   1   |   1   |   0  |  1  |
$2^3 + 2^1 + 2^0 = 13$
$13_{10} = 1101_{2}$


<br>

## 소수 계산

소수 자리에 2를 곱하여 나오는 값의 정수 부분을 오른쪽부터 나열한다. 

0.5를 2진수로 변환하는 계산 과정이다. 

> $0.5\times2=1.0$ → 소수 부분이 0
$0.5_{10} = 0.1_{2}$


<br>


## 실수 계산

다음의 계산을 통해 구한 정수 부분 $1101_{2}$ 과 실수 부분 $0.1_{2}$ 을 합하면 $13.5_{10}=1101.1_{2}$이 된다. 이런 과정으로 소수점이 있는 수를 계산할 수 있다. 

<br><br>

---


# 실수를 2진수로 
`console.log(1.3 + 0.1 == 1.4)` 를 컴퓨터가 계산하는 방식으로 계산해보자. 
<br>

## 1.3

정수 부분 $1_{10}=1_{2}$
소수 부분 $0.3_{10}=0.100110011001···_{2}$

> $0.3\times2=0.6$ → 0
$0.6\times2=1.2$ → 1
$0.2\times2=0.4$ → 0
$0.4\times2=0.8$ → 0
$0.8\times2=1.6$ → 1
$0.6\times2=1.2$ → 1 <반복>
$0.0100110011001···$ 

$1.3_{10}=1.1001100···_{2}$
<br>

## 0.1

소수 부분 $0.1_{10}=0.100110011001···_{2}$

> $0.1\times2=0.2$ → 0
$0.2\times2=0.4$ → 0
$0.4\times2=0.8$ → 0
$0.8\times2=1.6$ → 1
$0.6\times2=1.2$ → 1
$0.2\times2=0.4$ → 0 <반복>
$0.0100110011001···$ 

$0.1_{10}=0.00110011···_{2}$
<br>

## 1.3 + 0.1 = ?

컴퓨터는 각각의 숫자를 2진수로 변환한 후 2진수끼리 연산을 한다. 위 실수를 2진수로 변환했더니 모두 소수 자리가 무한히 반복된다. 컴퓨터는 이를 어떻게 처리할까?

1.3이나 0.1의 2진수처럼 무한 반복되는 실수 셀 수 없는 불가산의 집합이다. 컴퓨터는 이러한 실수의 **근사값**을 저장한다. 저장된 근사값끼리 연산을 하여 결과값을 도출하게 된다. 근사값은 실제 값과 가까운 값이지 실제 값은 아니기에 그 사이의 오차를 줄이는 것이 중요하다. 
<br>


---
## 부동 소수점 방식

컴퓨터가 실수를 저장하는 방식은 크게 2가지가 있다. 

1. 고정 소수점 방식 : 소수점의 위치를 정하여 표현
2. 부동 소수점 방식 : 지수를 사용

부동부동 소수점 방식은 고정 소수점 방식에 비해 소수자리의 표현 범위가 훨씬 넓다. 따라서 오차를 줄이는데 **부동 소수점 방식**이 고정 소수점 방식보다 유리하다고 말할 수 있다. (사용 분야에 따라 고정 소수점 방식이 효과적으로 사용될 수는 있다.) 

현재 자바스크립트를 비롯한 대부분의 컴퓨터 시스템은 **부동 소수점 방식**을 사용하고 있으며, 그 표준안으로 IEEE 754이 있다. **자바스크립트의 JS엔진**은 IEEE 754 표준안을 따른다.
<br><br>

---

# 결론


`console.log(1.3 + 0.1 == 1.4);` 코드의 내부 처리 흐름을 정리하자면 다음과 같다.

1. 입력받은 실수를 자바스크립트에서는 IEEE 754 표준안에 따라 근사값인 2진수로 변환하여 저장한다. 
2. 저장된 2진수끼리 덧셈이 이루어진다.
3. `1.3+0.1`의 연산된 결과로 `1.4000000000000001`이 출력된다.
4. $1.4000000000000001≠1.4$ 이므로 비교연산의 결과는 `false`가 된다.
<br>

## 실수를 비교하려면?

**오차 허용 범위**를 두고 비교하면 된다. 


### almostEqual 함수
```js
function almostEqual(a, b, epsilon = Number.EPSILON) {
  return Math.abs(a - b) < epsilon;
}

const a = 1.3 + 0.1;
const b = 1.4;

console.log(almostEqual(a, b));
```

<br>

- `Number.EPSILON`은 자바스크립트의 내장 상수로 2.220446049250313e-16의 값을 가진다. 0과 가까운 아주 작은 값이라고 보면 된다. 
- `epsilon`을 아주 작은 값으로 두었다.
- `Math.abs(a - b)` 두 수의 차이 = **오차 범위**
- 오차 범위가 아주 작을 때 `False`를 반환한다.
<br>

`console.log(almostEqual(a, b));` 는 `True`를 반환하게 된다.
<br><br>

---

## reference

1. [MDN: Number.EPSILON](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Number/EPSILON)
2. [Wikipedia: IEEE 754](https://en.wikipedia.org/wiki/IEEE_754)
3. [Floating Point Guide](https://floating-point-gui.de/)










