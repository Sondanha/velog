# 자바스크립트 개요

📅 2025-05-15T07:07:27.582Z

🔗 [원문 링크](https://velog.io/@son-dan-ha/자바스크립트-개요)

---


자바스크립트로 웹과 서버를 공부하고 있다. 자바스크립트가 어떤 언어이며 어떻게 작동하는지 그 내용을 개괄적으로 담아보았다. 공부하며 헷갈린 개념과 궁금했던 내용을 위주로 담았다.

---

# 자바스크립트는 어떤 언어인가?

## 웹과 JavaScript

웹 페이지는 HTML과 CSS로 구조와 스타일을 잡고, 자바스크립트로 사용자와의 상호작용 및 동작을 제어한다. 

아이디와 비밀번호를 입력하고 로그인 버튼을 클릭하면 로그인을 할 수 있는 웹 페이지를 생각해보자. 사용자가 보는 입력칸과 로그인 버튼은 HTML과 CSS로 만든다. 이때 사용자는 자신이 입력한 아이디와 비밀번호가 맞다면 로그인 버튼을 눌렀을 때 로그인이 되는 상황을 기대할 것이다. 이 상황을 자바스크립트로 구현하는 것이다. 

사용자가 입력한 아이디와 비밀번호가 존재하는지와 규칙에 맞게 입력했는지 등을 확인하고, 버튼이 클릭되면 로그인 상태를 유지하면서 특정 페이지로 넘어가게 하는 등의 동작을 만든다. 
<br>

## ECMAScript

과거, 각 브라우저마다 자바스크립트 언어가 구현되는 방식이 달라 표준화할 필요성이 생겼다. 

ECMA는 표준 사양이며 그중 ECMA-262는 자바스크립트의 표준 사양이다. ECMAScript는 이 표준 사양을 따르는 공식 언어를 말하기 위한 용어다. 

![](https://velog.velcdn.com/images/son-dan-ha/post/e364ad16-4cbb-42c6-9aa6-8e958f3df334/image.png)

<br>

## 오늘날의 JavaScript

따라서 원래 자바스크립트는 html에 종속된 언어로 웹 브라우저에서만 실행되었다. 하지만 오늘날 자바스크립트는 범용성을 갖게 되었다. 
기존에 웹에서만 사용되는 것을 넘어 서버에서도 사용되고, 컴퓨터 자체에 **JavaScript 엔진**을 탑제하여 사용된다. 

<br>

---
# JavaScript 런타임

### JavaScript 엔진

앞서 자바스크립트는 **브라우저**에서 실행된다고 했다. 우리가 작성한 자바스크립트 코드가 브라우저에서 어떻게 실행되는지 알아보겠다. 

JavaScript 엔진은 코드를 실행하는 주체로 각 브라우저에는 **JavaScript 엔진**이 탑제되어있다. 크롬, 익스플로러, 사파리, 파이어폭스 등 주요 브라우저는 각각이 개발한 JavaScript 엔진을 가지고 있다. 그중 **V8**은 크롬의 JavaScript 엔진이다. 

### JavaScript 런타입

브라우저에 탑제된 **JavaScript 엔진**은 **JavaScript 런타임**의 일부이다. 다음 그림을 통해 JavaScript 런타임에 대해 간단하게 알아보자.

![](https://velog.velcdn.com/images/son-dan-ha/post/e43704fd-715b-405b-9c6c-29300c44b3e7/image.png)


그림을 통해 작성한 코드가 브라우저에서 실행되기 위해서는 js 엔진뿐만 아니라 브라우저가 제공하는 API, 큐, 이벤트 루프가 필요하다는 것을 알 수 있다. 

js 엔진은 변수를 저장하는 메모리 힙과 코드를 실행하는 콜 스택으로 구성되어 있다. 큐는 비동기 작업이 시작되기 전 가중치를 부여하고 이벤트 루프는 비동기 작업이 올바른 순서대로 실행되게 한다. 

추후 각 요소와 작동 구조에 대해 더 자세히 다루어 보겠다.
<br>

---
# 비동기

## 자바스크립트 언어의 특징
<br>

```js
function A() {
	console.log("A")
}
function B() {
	console.log("B")
}
A()
B()
```

다음 코드는 어떻게 실행될까? 아마 아래와 같이 출력될 것으로 당연하게 생각할 수 있다.

```text
A
B
```
<br>
 코드의 흐름을 보면 1행부터 6행까지 함수 A와 B를 등록 후 5행과 6행에서 각각 함수 A와 B를 호출했다. 함수가 호출 순서대로 실행되어 "A" 출력 후 "B"가 출력된다. 이처럼 자바스크립트의 코드는 위에서 한 줄씩 실행된다. 이름 동기라고 한다. 또한 함수가 실행되는 내부의 과정에서는 blocking 이 일어난다. 함수 A와 함수 B가 동시에 실행되지 않도록 특정 함수가 실행되는 동안에는 다른 함수가 실행되는 것을 막는다. 

<br>

### 1. 동기적
- 코드는 위에서 아래로 한 줄씩 실행됨.
### 2. blocking 
- 함수 A의 실행이 완료되어야 함수 B가 실행됨.
- A가 실행되는 동안 B의 실행을 차단함.

<br>

### 싱글스레드

자바스크립트의 프로세스 실행 방식의 특징이 하나 더 있다. 
바로 싱글스레드다. 자바스크립트의 V8엔진은 싱글스레드를 사용한다. 

싱글스레드란 한 번에 하나의 작업만 실행하며 작업이 순차적으로 처리된다. 반대의 개념이 멀티스레드로 이는 여러 작업을 동시에 처리할 수 있다. 

CPU 사용의 관점에서 보면 싱글스레드는 하나의 코어를 사용하고 멀티스레드는 여러 코어를 병렬적으로 사용하기에 비효율이 발생할 수 있는 싱글스레드보다는 효율이 높다고 볼 수 있다. 
<br>

## 비동기의 필요성

동기적, blocking, 싱글스레드의 특징을 가진 자바스크립트는 하나의 일이 처리되는 동안에는 다른 일을 처리할 수 없기에 비효율적인 상황이 생길 수 있으며, 사용자의 입장에서 한 동작에 오랜 시간이 걸린다면, 브라우저가 작동을 멈춘 것처럼 보일 수 있다.

따라서 이러한 문제를 극복하기 위해 자바스크립트 외에 브라우저에서 비동기 함수가 추가되어야 했다. 자바스크립트에서 비동기를 사용하면 효율성을 높이고, 사용자의 경험 개선할 수 있다. 

---
# 비동기 함수

간단하게 비동기 함수 몇가지만 알아보겠다. 우선 시간과 간격에 관한 함수다. 

## Timeouts and Intervals
### 1. setTimeout

`setTimeout(function, duration, 'param1','param2',..)`

```js
function A(name) {
	console.log(`my name is {name}`)
}
setTimeout(A, 2000, 'dana') // 2초 뒤 'my name is dana' 출력
```

`clearTimeout()` 으로 `setTimeout` 실행시키지 않을 수 있다. 

- duration 매개변수는 최소 지연시간이다. 

- 자바스크립트는 콜 스택에서 코드를 실행하므로 콜 스택이 비어야 다음 함수를 실행할 수 있다. 따라서 duration 매개변수는 최소 지연 시간이다. 콜 스택이 빈 이후부터의 지연시간이기 때문이다. 또한 매번 그 시간은 바뀔 수 있다.
<br>

### 2. setInterval

`setInterval(function, duration, 'param1','param2',..)`

- setTimeout은 지연 시간 이후 한번 실행이라면 setInterval은 기간을 두고 지속적으로 실행된다.
- duration 매개변수는 시간 간격을 보장한다. 

- setTimeout과는 동작 방식에서 차이가 있다. 예를들어 시간 간격(매개변수)을 2초 설정하였을 때 setInterval은 함수를 실행하는데에 1초가 걸린다면 시간 간격을 1초로 하여 2초라는 간격을 보장한다. 즉, 고정된다.
<br>

---
## Callbacks

### 1. Callback 함수
- 자바스크립트에서 함수는 다른 함수의 인자로 넘길 수 있다. 
- 콜백함수란 다른 함수에 **인자로 전달되는 함수**이다. 
- 실행됨에 있어서 다른 함수에 의해 실행될 수밖에 없다.
<br>

### 2. higherOrder 함수
- 다른 인자나 반환값에 함수를 넘길 수 있는 함수
- 콜백 함수를 실행시키는 함수

```js
function A(name) {
	console.log(`Hi, ${name}`)
}
function higherOrderFunction(callback) {
	const name = 'dana'
	callback(name)
}
higherOrderFunction(A)
```

---

### 동기적 콜백
- 즉시 실행됨
<br>

### 비동기적 콜백
- 특정 시간이나 이벤트가 발생할 때까지 함수 실행을 지연하는데 사용한다.
- 보통 데이터 패칭에는 시간이 걸리기에 비동기적 콜백 함수가 필요하다.

```js
function A(name) {
	console.log(`my name is {name}`)
}
setTimeout(A, 2000, 'dana')
```
- `setTimeout` 은 `higherOreder` 함수의 역할을, `A`는 `callback` 함수의 역할을 한다.

```js
function callback() {
	document.getElementById("demo").innerHTMl = "Hi"
}
document.getElementById("btn").addEventListener("click",callback)
```
<br>

### 콜백 중첩

이전에 가져온 요청으로 얻은 데이터를 기반으로 계속해서 요청이 생겨나면, 콜백 함수가 과도하게 중첩되는 callback hell 문제 발생한다. 

이를 해결하기 위해 Promise가 도입되었다.
<br>

---
## Promise

프로미스는 자바스크립트의 객체로 콜백보다 비동기 코드를 더 간단하게 처리하도록 도와준다. 


### 프로미스의 3가지 상태

프로미스는 항상 다음 3가지 상태중 하나의 상태다

#### 1. pending
- 초기상태. 거절되지도 이행되지도 않은 상태

#### 2. fulfilled 
 - 프로미스가 충족된 상태로 프로미스에서 반환된 결과(return Promise value)에 성공 콜백이 첨부된다.
 
#### 3. rejected 
- 프로미스가 거부된 상태로 프로미스에서 반환된 결과에 실패 콜백이 첨부된다

<br>

### 프로미스의 6가지 요점

1. 프로미스 (Promise) 
	- 값에 대한 대리인, 중계자(proxy)
    
2. 프로미스 값 (Promise value) 
	- 프로미스가 생성될 때에는 알 필요가 없다.
    
3. 이행된 프로미스 (Fulfilled promise)

4. 거부된 프로미스 (Rejected Promise)

5. 성공 콜백 (Success callback)

6. 실패 콜백 (Failure callback)

<br>


#### 프로미스 생성

```js
const promise = new Promise()
```
<br>

#### 이행 및 거부

```js 
const promise = new Promise((resolve, reject) => {
	resolve()
})
```
- 프로미스 상태를 pending -> fulfilled 변경


```js
const promise = new Promise((resolve, reject) => {
	reject()
})
```
- 프로미스 상태를 pending -> rejected 변경

<br>

#### 콜백 함수 실행

Promise 객체에서 결과(성공/실패)를 처리하는 메서드로 비동기 작업 후 처리됨.  

- 다음 프로미스 핸들러를 이용하여 콜백 함수를 첨부한다.

1. `.then()` : 프로미스 이행되면 실행할 콜백 함수를 담고 처리
2. `.catch()` : 거부되면 실행할 콜백 함수를 담고 처리
3. `.finally()` : 상관없이 콜백 함수 담아 처리
<br>

```js
// 프로미스의 객체를 반환하는 함수
const promise = new Promise((resolve, reject) => {
	setTimeout(()=> {
		resolve()
	}, 5000)
})
const promise = new Promise((resolve, reject) => {
	setTimeout(()=> {
		reject()
	}, 5000)
})

// 결과 처리 함수
promise.then(onFulfillment) // pending -> fulfilled 변경
promise.catch(onRejection) // pending -> rejected 변경

const onFulfillment = (result) => {
	console.log(result)
}
const onRejection = (error) => {
	console.log(error)
}
```
<br>

#### 프로미스 체이닝

프로미스 핸들러는 프로미스 객체를 반환하므로 다음처럼 체이닝할 수 있다. 

```js
promise 
	.then((result) => {
	console.log(result)
	}) 
	.catch((error) => {
	console.log(error)
	}) 
	.finally((result) => {
	console.log("끝")
	});
```
<br>

---
### Static methods 3가지

#### Promise.all()
프로미스의 반복가능한 항목을 입력받고 각 항목에 대한 결과를 배열로 반환한다.
- resolve : 모든 프로미스가 resolve 되거나 프로미스가 없는 경우
- reject : 하나라도 reject 되거나 오류 등에 의해 reject 되는 경우

```js
const promise1 = Promise.resolve(3); // 즉시 결과 가져옴
const promise2 = 42; // 프로미스x
const promise3 = new Promise((resolve, reject) => {
	setTimeout(resolve, 100, 'foo'); // 
});
// Promise.all()에 배열로 전달
Promise.all([promise1, promise2, promise3]).then((values) => {
	console.log(values);
});
```

```
Array [3, 42, "foo"]
```
<br>

#### Promise.allSettled()
하나가 거부되는 것과 관계없이 모든 프로미스가 완료될 때까지 기다린 후 반환한다.
<br>

#### Promise.race()
하나의 프로미스가 fulfill되거나 reject 되는 즉시 해당 프로미스 값을 반환한다.

```js
const promise1 = new Promise((resolve, reject) => {
	setTimeout(resolve, 500, 'one');
})
const promise2 = new Promise((resolve, reject) => {
	setTimeout(resolve, 100, 'two');
})

Promise.race([promise1, promise2]).then((value) => {
	console.log(values);
	// 두개 모두 resolve, 그러나 promise2가 더 빠름
});
```

```
"two"
```


